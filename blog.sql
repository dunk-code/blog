/*
 Navicat Premium Data Transfer

 Source Server         : 192.168.43.227-MYSQL
 Source Server Type    : MySQL
 Source Server Version : 50561
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50561
 File Encoding         : 65001

 Date: 10/04/2021 21:05:07
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for hibernate_sequence
-- ----------------------------
DROP TABLE IF EXISTS `hibernate_sequence`;
CREATE TABLE `hibernate_sequence`  (
  `next_val` bigint(20) NULL DEFAULT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of hibernate_sequence
-- ----------------------------
INSERT INTO `hibernate_sequence` VALUES (83);

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint(20) NOT NULL,
  `appreciation` bit(1) NOT NULL,
  `commentabled` bit(1) NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `first_picture` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `views` int(11) NULL DEFAULT NULL,
  `type_id` bigint(20) NULL DEFAULT NULL,
  `user_id` bigint(20) NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK292449gwg5yf7ocdlmswv9w4j`(`type_id`) USING BTREE,
  INDEX `FK8ky5rrsxh01nkhctmo7d48p82`(`user_id`) USING BTREE,
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (41, b'1', b'1', '## PO Entity\r\npersisent object 持久对象\r\n有时也被称为Data对象，对应数据库中的entity，可以简单的认为一个PO对应数据库中的一条记录\r\n\r\n## VO\r\nview project 表现层对象\r\n主要对应页面系显示(web页面/swt/swing界面)的数据对象。\r\n可以和表对应，也可以不对应，分局业务的需要\r\n\r\n## DTO(TO)\r\ndata transfer object 数据传输对象\r\n比如一张表有100个字段，那么对应的PO就有100个属性，大多数情况下，DTO的数据来自多个表，但view层只需要显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以只使用这10个属性的DTO来传输数据到client，这样不会暴露server端表结构。到达客户端后，如果用这个对象来对应界面显示，那此时他的身份就是VO\r\n\r\n## POJO\r\nplain ordinary java object 无规则简单java对象\r\n一个中间对象，可以转换为PO、DTO、VO\r\nPOJO持久化后===>PO\r\nPOJO用作表示层===>VO\r\nPOJO传输过程中===>DTO\r\n', '2021-04-07 17:50:01', 'https://picsum.photos/id/277/300/200', '原创', b'1', b'1', b'1', '实体类定义规则', '2021-04-08 16:49:29', 40, 33, 1, 'persisent object 持久对象\r\n有时也被称为Data对象，对应数据库中的entity，可以简单的认为一个PO对应数据库中的一条记录');
INSERT INTO `t_blog` VALUES (44, b'1', b'1', '如果了解springboot如何整合shiro可以跳过介绍\r\n@[TOC](这里写目录标题)\r\n\r\n\r\n\r\n\r\n##  什么是Shiro\r\n	\r\nApache Shiro是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。借助Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。\r\n## Shiro的三大核心概念\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210329201432666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Nzk2MjA4,size_16,color_FFFFFF,t_70)\r\n\r\n###### Subject：\r\n主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如爬虫、机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者。\r\n###### SecurityManager：\r\n安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是shiro的核心, SecurityManager相当于spring mvc中的dispatcherServlet前端控制器。\r\n###### Realm：\r\n域，shiro从Realm获取安全数据(如用户、角色、权限)，就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。\r\n## Shiro功能介绍\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210329201028821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Nzk2MjA4,size_16,color_FFFFFF,t_70)\r\n###### Authentication：\r\n身份认证/登录，验证用户是不是拥有相应的身份；\r\n###### Authorization：\r\n授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用 户是否能进行什么操作，如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限\r\n###### Session Manager：\r\n会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有\r\n信息都在会话中；会话可以是普通 JavaSE 环境，也可以是 Web 环境的\r\n###### Cryptography：\r\n加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；\r\nWeb Support：Web 支持，可以非常容易的集成到Web 环境；\r\n###### Caching：\r\n缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；\r\n###### Concurrency：\r\nShiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能\r\n把权限自动传播过去；\r\n###### Testing：\r\n提供测试支持；\r\n###### Run As：\r\n允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；\r\n###### Remember Me：\r\n记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了\r\n\r\n## Shiro面试题(待补充)\r\n[Shiro面试题1](https://blog.csdn.net/qq_37254736/article/details/99350029)\r\n[Shiro面试题2](https://blog.csdn.net/url_9507/article/details/100675089?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242)\r\n# Springboot整合Shiro\r\n#### 导入依赖\r\n```xml\r\n<!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring -->\r\n        <dependency>\r\n            <groupId>org.apache.shiro</groupId>\r\n            <artifactId>shiro-spring</artifactId>\r\n            <version>1.7.1</version>\r\n        </dependency>\r\n```\r\n#### 配置javaConfig\r\n三大核心对象ShiroFilterFactoryBean、DefaultWebSecurityManager、Realm\r\n\r\n###### 常用拦截器分类说明\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210329204614874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Nzk2MjA4,size_16,color_FFFFFF,t_70)\r\n###### javaConfig\r\n```java\r\n@Configuration\r\npublic class ShiroConfig {\r\n\r\n    //ShiroFilterFactoryBean\r\n    @Bean\r\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Autowired DefaultWebSecurityManager securityManager) {\r\n        ShiroFilterFactoryBean filterFactoryBean = new ShiroFilterFactoryBean();\r\n        filterFactoryBean.setSecurityManager(securityManager);\r\n        \r\n        Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();\r\n\r\n        //拦截\r\n        filterChainDefinitionMap.put(\"/user/add\", \"authc\");\r\n        filterChainDefinitionMap.put(\"/user/update\", \"authc\");\r\n        filterChainDefinitionMap.put(\"/user/*\", \"authc\");\r\n        filterChainDefinitionMap.put(\"/logout\", \"logout\");//退出\r\n        /*filterChainDefinitionMap.put(\"/*\",\"authc\");*/\r\n\r\n        //授权\r\n        filterChainDefinitionMap.put(\"/user/add\",\"perms[user:add]\");\r\n        filterChainDefinitionMap.put(\"/user/update\",\"perms[user:update]\");\r\n\r\n\r\n        //设置登录的请求\r\n        filterFactoryBean.setLoginUrl(\"/toLogin\");\r\n\r\n        //设置未授权页面\r\n        filterFactoryBean.setUnauthorizedUrl(\"/unauth\");\r\n\r\n\r\n        filterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);\r\n\r\n        return filterFactoryBean;\r\n    }\r\n\r\n    //DefaultWebSecurityManager\r\n    @Bean\r\n    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Autowired UserRealm userRealm) {\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\r\n        securityManager.setRealm(userRealm);\r\n        return securityManager;\r\n    }\r\n\r\n    //Realm\r\n    @Bean\r\n    public UserRealm userRealm() {\r\n        return new UserRealm();\r\n    }\r\n}\r\n```\r\n#### Realm\r\n创建UserRealm继承AuthorizingRealm实现doGetAuthorizationInfo()、doGetAuthenticationInfo()方法\r\n\r\n从数据库中拿到用户信息，这里需要整合MyBatis、Druid相关依赖，具体的springboot整合MyBatis的代码这里就赘述了，如果自己联系，可以不从数据库中获取数据，可以自己直接设定默认的username和password\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210329205252748.png)\r\nperm是该用户的权限可以通过authorizationInfo.addStringPermissions();方法授权\r\n```java\r\npublic class UserRealm extends AuthorizingRealm {\r\n\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n\r\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\r\n        //authorizationInfo.addStringPermission(\"user:add\");\r\n\r\n        Subject currentUser = SecurityUtils.getSubject();\r\n        /**\r\n         *  通过session取值\r\n         */\r\n        /*Session session = currentUser.getSession();\r\n        String username = (String) session.getAttribute(\"username\");\r\n        System.out.println(username);\r\n        User user = userService.getByUsername(username);\r\n        authorizationInfo.addStringPermission(user.getPerm());\r\n        System.out.println(user.getPerm());*/\r\n\r\n        /**\r\n         * 通过principal取值\r\n         */\r\n        String username = (String) currentUser.getPrincipal();\r\n        System.out.println(username);\r\n        User user = userService.getByUsername(username);\r\n        System.out.println(user.getPerm());\r\n        String[] perms = user.getPerm().split(\",\");\r\n        ArrayList<String> permList = new ArrayList();\r\n        for (String perm : perms) {\r\n            permList.add(perm);\r\n        }\r\n        authorizationInfo.addStringPermissions(permList);\r\n        System.out.println(\"执行了======>授权\");\r\n        return authorizationInfo;\r\n    }\r\n\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\r\n        System.out.println(\"执行了======>认证\");\r\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\r\n        User user = userService.getByUsername(token.getUsername());\r\n        if (user == null) {\r\n            return null;\r\n        }\r\n        //密码可以加密\r\n        //密码认证，shiro加密\r\n        return new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(),\"\");\r\n    }\r\n}	\r\n```\r\n#### Controller\r\n\r\n```java\r\n@Controller\r\npublic class MyController {\r\n\r\n    @RequestMapping(\"/toLogin\")\r\n    public String toLogin() {\r\n        return \"login\";\r\n    }\r\n\r\n    @RequestMapping({\"/\",\"/index\"})\r\n    public String toIndex(Model model) {\r\n        model.addAttribute(\"msg\",\"Hello,Shiro\");\r\n        return \"index\";\r\n    }\r\n\r\n    @RequestMapping(\"/user/add\")\r\n    public String addUser() {\r\n        return \"user/add\";\r\n    }\r\n\r\n    @RequestMapping(\"/user/update\")\r\n    public String updateUser() {\r\n        return \"user/update\";\r\n    }\r\n\r\n    @PostMapping(\"/login\")\r\n    public String login(String username, String password, Model model) {\r\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\r\n        Subject currentUser = SecurityUtils.getSubject();\r\n            try {\r\n                currentUser.login(token);\r\n                Session session = currentUser.getSession();\r\n                session.setAttribute(\"username\", username);\r\n                return \"index\";\r\n            } catch (UnknownAccountException uae) {\r\n                model.addAttribute(\"msg\", token.getPrincipal() + \"用户名不匹配\");\r\n                return \"login\";\r\n            } catch (IncorrectCredentialsException ice) {\r\n                model.addAttribute(\"msg\", token.getPrincipal() + \"密码错误\");\r\n                return \"login\";\r\n            }\r\n    }\r\n\r\n    @ResponseBody\r\n    @RequestMapping(\"/unauth\")\r\n    public String unAuth() {\r\n        return \"未经授权\";\r\n    }\r\n\r\n    @RequestMapping(\"/logout\")\r\n    public String logout() {\r\n        return \"/login\";\r\n    }\r\n}\r\n\r\n```\r\n前端页面这里就不献丑了，大家自由发挥\r\n# Shiro实现记住我功能\r\n[Shiro实现记住我](https://blog.csdn.net/qq_34021712/article/details/80306442?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161702114716780274160174%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161702114716780274160174&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-80306442.pc_search_result_before_js&utm_term=springboot%20shiro%E8%AE%BE%E7%BD%AEremember)\r\n# Shiro整合thymeleaf\r\n## 导入依赖\r\n\r\n```xml\r\n<!--thymeleaf shiro整合包-->\r\n        <!-- https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro -->\r\n        <dependency>\r\n            <groupId>com.github.theborakompanioni</groupId>\r\n            <artifactId>thymeleaf-extras-shiro</artifactId>\r\n            <version>2.0.0</version>\r\n        </dependency>\r\n```\r\n## HTML页面命名空间\r\n\r\n```html\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\r\n      xmlns:shiro=\"http://www.pollix.at/thymeleaf/shiro\">\r\n```\r\n## 使用举例\r\n\r\n```html\r\n\r\n<div shiro:notAuthenticated=\"\"> <!--没有认证不显示-->\r\n    <p><button><a th:href=\"@{/toLogin}\">登录</a></button></p>\r\n</div>\r\n\r\n<div shiro:authenticated=\"\"><!--认证了显示-->\r\n    <p><button><a th:href=\"@{/logout}\">退出</a></button></p>\r\n</div>\r\n\r\n<hr/>\r\n<div shiro:hasPermission=\"user:update\"><!--有user:update 权限显示-->\r\n    <a th:href=\"@{/user/add}\">add</a>\r\n</div>\r\n<div shiro:hasPermission=\"user:add\"><!--有user:add权限显示-->\r\n    <a th:href=\"@{/user/update}\">update</a>\r\n</div>\r\n```', '2021-04-07 18:02:19', 'https://picsum.photos/id/257/300/200', '原创', b'1', b'1', b'1', 'springboot整合Shiro', '2021-04-08 16:49:23', 11, 45, 1, 'Apache Shiro是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。借助Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。');
INSERT INTO `t_blog` VALUES (49, b'1', b'0', '请求重定向和转发\r\n当处理器对请求处理完毕后，向其它资源进行跳转是，有两种跳转方式：请求转发与重定向。而根据索要跳转的资源类型，又可分为两类：跳转到页面与跳转到其他处理器。\r\n\r\n注意：对于请求转发的页面，可以是WEB-INF中页面，而重定向的页面，是不能为WEB-INF中的，因为重定向相当于用户再次发出一次请求，而用户不能直接访问WEB-INF中的资源。\r\n\r\n\r\n\r\nSpringMVC框架把原来Servlet中的请求转发和重定向操作进行了封装，现在可以使用简单的方式实现转发和重定向。\r\n\r\nforward：表示转发，实现request.getRequestDispathcer(\"xx.jsp\").forward();\r\n\r\nredirect：表示重定向，实现response.sendRediect(\"xxx.jsp\");\r\n\r\n请求转发\r\n处理器方法返回 ModelAndView 时，需在 setViewName()指定的视图前添加 forward:，且此时的视图不再与视图解析器一同工作，这样可以在配置了解析器时指定不同位置的视图。视图页面必须写出相对于项目根的路径。forward 操作不需要视图解析器。处理器方法返回 String,在视图路径前面加入 forward: 视图完整路径。\r\n\r\n@RequestMapping(value = \"/some\",produces = \"text/plain;charset=utf-8\")\r\npublic ModelAndView testForward(String name,Integer age){\r\n    ModelAndView mv = new ModelAndView();\r\n    mv.addObject(\"name\",name);\r\n    mv.addObject(\"age\",age);\r\n    mv.setViewName(\"forward:/WEB-INF/view/show.jsp\");\r\n    return mv;\r\n}\r\n请求重定向\r\n在处理器方法返回的视图字符串的前面添加 redirect:，则可实现重定向跳转。\r\n\r\n@RequestMapping(value = \"/other\")\r\npublic ModelAndView testRedirect(String name,Integer age){\r\n    ModelAndView mv = new ModelAndView();\r\n    mv.addObject(\"name\",name);\r\n    mv.addObject(\"age\",age);\r\n    mv.setViewName(\"redirect:/other.jsp\");\r\n    return mv;\r\n}\r\n异常处理\r\n使用注解@ExceptionHandler 可以将一个方法指定为异常处理方法。该注解只有一个可选属性 value，为一个 Class<?>数组，用于指定该注解的方法所要处理的异常类，即所要匹配的异常。而被注解的方法，其返回值可以是 ModelAndView、String，或 void，方法名随意，方法参数可以是 Exception 及其子类对象、HttpServletRequest、HttpServletResponse 等。系统会自动为这些方法参数赋值。对于异常处理注解的用法，也可以直接将异常处理方法注解于 Controller 之中。\r\n\r\n代码演示\r\n\r\n第一步：自定义两个异常类\r\n\r\npublic class MyException extends Exception {\r\n    public MyException() {\r\n        super();\r\n    }\r\n\r\n    public MyException(String message) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\npublic class AgeException extends MyException {\r\n    public AgeException() {\r\n        super();\r\n    }\r\n\r\n    public AgeException(String message) {\r\n        super(message);\r\n    }\r\n}\r\n\r\npublic class NameException extends MyException {\r\n    public NameException() {\r\n        super();\r\n    }\r\n\r\n    public NameException(String message) {\r\n        super(message);\r\n    }\r\n}\r\n第二步：在controller方法中抛出异常\r\n\r\n@RequestMapping(value = \"exception\")\r\npublic ModelAndView askForException(String name,Integer age) throws MyException {\r\n    ModelAndView mv = new ModelAndView();\r\n    if(!\"zs\".equals(name)){\r\n        throw new NameException(\"姓名不正确！！！\");\r\n    }\r\n    if (age == null || age > 80){\r\n        throw new AgeException(\"年龄太大了！！！\");\r\n    }\r\n    mv.addObject(\"name\",name);\r\n    mv.addObject(\"age\",age);\r\n    mv.setViewName(\"show\");\r\n    return mv;\r\n第三步：定义三个异常响应页面\r\n\r\nnameError.jsp\r\n<br/>\r\n提示信息：${msg}\r\n<br/>\r\n系统信息：${ex.message}\r\n\r\nageError.jsp\r\n<br/>\r\n提示信息：${msg}\r\n<br/>\r\n系统信息：${ex.message}\r\n\r\notherError.jsp\r\n<br/>\r\n提示信息：${msg}\r\n<br/>\r\n系统信息：${ex.message}\r\n第四步：定义全局异常处理类\r\n\r\n@ControllerAdvice\r\npublic class GlobalExceptionHandler {\r\n    @ExceptionHandler(value = NameException.class)\r\n    public ModelAndView nameException(Exception ex){\r\n        ModelAndView mv = new ModelAndView();\r\n        mv.addObject(\"msg\",\"姓名不是zs\");\r\n        mv.addObject(\"ex\",ex);\r\n        mv.setViewName(\"nameError\");\r\n        return mv;\r\n    }\r\n    @ExceptionHandler(value = AgeException.class)\r\n    public ModelAndView ageException(Exception ex){\r\n        ModelAndView mv = new ModelAndView();\r\n        mv.addObject(\"msg\",\"年龄超过80岁啦\");\r\n        mv.addObject(\"ex\",ex);\r\n        mv.setViewName(\"ageError\");\r\n        return mv;\r\n    }\r\n    @ExceptionHandler\r\n    public ModelAndView otherException(Exception ex){\r\n        ModelAndView mv = new ModelAndView();\r\n        mv.addObject(\"msg\",\"未知异常\");\r\n        mv.addObject(\"ex\",ex);\r\n        mv.setViewName(\"otherError\");\r\n        return mv;\r\n    }\r\n}\r\n第五步：在spring配置controller和handler的注解扫描\r\n\r\n<!--开启Controller注解扫描-->\r\n<context:component-scan base-package=\"school.xauat.controller\"></context:component-scan>\r\n<!--配置视图解析器-->\r\n<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n    <property name=\"prefix\" value=\"/WEB-INF/view/\"></property>\r\n    <property name=\"suffix\" value=\".jsp\"></property>\r\n</bean>\r\n<!--开启注解驱动-->\r\n<mvc:annotation-driven></mvc:annotation-driven>\r\n<!--开启ControllerAdvice注解扫描-->\r\n<context:component-scan base-package=\"school.xauat.handler\"></context:component-scan>\r\nSpringMVC拦截器\r\nSpringMVC 中的 Interceptor 拦截器是非常重要和相当有用的，它的主要作用是拦截指定的用户请求，并进行相应的预处理与后处理。其拦截的时间点在“处理器映射器根据用户提交的请求映射出了所要执行的处理器类，并且也找到了要执行该处理器类的处理器适配器，在处理器适配器执行处理器之前”。当然，在处理器映射器映射出所要执行的处理器类时，已经将拦截器与处理器组合为了一个处理器执行链，并返回给了中央调度器。\r\n\r\n定义拦截器类\r\n\r\npublic class myInterceptor implements HandlerInterceptor {\r\n    private Long beginTime;\r\n    @Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n        System.out.println(\"preHandle方法执行\");\r\n        beginTime = System.currentTimeMillis();\r\n        return true;\r\n    }\r\n    @Override\r\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\r\n        System.out.println(\"postHandle方法执行\");\r\n    }\r\n    @Override\r\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r\n        System.out.println(\"afterCompletion方法执行\");\r\n        Long endTime = System.currentTimeMillis();\r\n        System.out.println(\"程序执行时间\" + (endTime - beginTime) + \"ms\");\r\n    }\r\n}\r\n在springMVC配置文件注册拦截器\r\n\r\n<mvc:interceptors>\r\n     <mvc:interceptor>\r\n          <mvc:mapping path=\"/**\"/>\r\n          <bean class=\"school.xauat.handler.MyInterceptor\"></bean>\r\n     </mvc:interceptor>\r\n</mvc:interceptors>\r\n自定义拦截器，需要实现 HandlerInterceptor 接口。而该接口中含有三个方法：\r\n\r\npreHandle(request,response, Object handler)：\r\n\r\n该方法在处理器方法执行之前执行。其返回值为 boolean，若为 true，则紧接着会执行处理器方法，且会将 afterCompletion()方法放入到一个专门的方法栈中等待执行。\r\n\r\npostHandle(request,response, Object handler,modelAndView)：\r\n\r\n该方法在处理器方法执行之后执行。处理器方法若最终未被执行，则该方法不会执行。由于该方法是在处理器方法执行完后执行，且该方法参数中包含 ModelAndView，所以该方法可以修改处理器方法的处理结果数据，且可以修改跳转方向。\r\n\r\n afterCompletion(request,response, Object handler, Exception ex)：\r\n\r\n当 preHandle()方法返回 true 时，会将该方法放到专门的方法栈中，等到对请求进行响应的所有工作完成之后才执行该方法。即该方法是在中央调度器渲染（数据填充）了响应页面之后执行的，此时对 ModelAndView 再操作也对响应无济于事。\r\n\r\nafterCompletion 最后执行的方法，清除资源，例如在 Controller 方法中加入数据\r\n\r\n拦截器中方法和处理器方法的执行顺序如下图\r\n\r\n\r\n\r\n当有多个拦截器时\r\n\r\n\r\n\r\n拦截器过滤器的区别\r\n拦截器和过滤器的区别\r\n\r\n1、过滤器是Servlet中的对象。拦截器是框架中的对象\r\n\r\n2、过滤器是实现Filter接口的对象。拦截器是实现HandlerInterceptor接口\r\n\r\n3、过滤器用来设置request和response的参数、属性。\r\n\r\n4、过滤器是在拦截器之前先执行的\r\n\r\n5、过滤器是Tomcat服务器中创建的对象，拦截器是springmvc容器中创建的对象\r\n\r\n6、过滤器是一个执行时间点，拦截器有三个执行时间点\r\n\r\n7、过滤器可以处理jsp、js、html等，拦截器是侧重拦截对controller的对象，如果你的请求不能被中央调度器接受，这个请求就不会执行拦截内容\r\n\r\nSpringMVC执行流程理解\r\n\r\n\r\nSpringMVC执行流程分析\r\n（1）浏览器提交请求到中央调度器\r\n\r\n（2）中央调度器直接将请求转给处理器映射器。\r\n\r\n（3）处理器映射器会根据请求，找到处理该请求的处理器，并将其封装为处理器执行链后返回给中央调度器。\r\n\r\n（4）中央调度器根据处理器执行链中的处理器，找到能够执行该处理器的处理器适配器。\r\n\r\n（5）处理器适配器调用执行处理器。\r\n\r\n（6）处理器将处理结果及要跳转的视图封装到一个对象 ModelAndView 中，并将其返回给处理器适配器。\r\n\r\n（7）处理器适配器直接将结果返回给中央调度器。\r\n\r\n（8）中央调度器调用视图解析器，将 ModelAndView 中的视图名称封装为视图对象。\r\n\r\n（9）视图解析器将封装了的视图对象返回给中央调度器\r\n\r\n（10）中央调度器调用视图对象，让其自己进行渲染，即进行数据填充，形成响应对象。\r\n\r\n（11）中央调度器响应浏览器。\r\n\r\n', '2019-01-07 18:05:23', 'https://picsum.photos/id/237/300/200', '原创', b'0', b'1', b'0', 'SpringMVC核心技术', '2021-02-08 16:46:14', 6, 45, 1, '当处理器对请求处理完毕后，向其它资源进行跳转是，有两种跳转方式：请求转发与重定向。而根据索要跳转的资源类型，又可分为两类：跳转到页面与跳转到其他处理器。');
INSERT INTO `t_blog` VALUES (58, b'0', b'0', 'springMVC简介\r\nspringMVC又 叫Spring web mvc。是Spring框架中的一部分，是Spring3.0后发布的。\r\n\r\nSpringMVC框架的优点\r\n1、基于MVC架构模式：MVC架构模式\r\n\r\n2、容易理解上手快，使用简单：可以开发一个注解的SpringMVC项目，SpringMVC也是轻量级的框架，jar包很小，不依赖特定的接口和类。\r\n\r\n3、作为Spring的一部分，能够使用Spring框架的IOC容器和Aop编程。方便整合Strtus、MyBatis、Hibernate、JPA等其他框架。\r\n\r\n4、SpringMVC强化注解的使用，在控制器，Service、Dao都可以使用注解，方便灵活。使用@Controller创建对象容器，@Service创建业务对象，@AutoWired或者@Resource在控制器类中注入Service，Service类中注入Dao。\r\n\r\n第一个SpringMVC程序\r\n所谓SpringMVC注解式开发是指，在代码中通过对类与方法的注解，便可以完成处理器在springMVC容器的注册。注册是开发的重点\r\n\r\n步骤\r\n\r\n第一步：创建maven-web项目\r\n\r\n\r\n\r\n第二步：在pom.xml中添加依赖和插件\r\n\r\n加入servlet、jsp、springmvc依赖\r\n\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>junit</groupId>\r\n        <artifactId>junit</artifactId>\r\n        <version>4.11</version>\r\n        <scope>test</scope>\r\n    </dependency>\r\n    <!--加入servlet依赖-->\r\n    <dependency>\r\n        <groupId>javax.servlet</groupId>\r\n        <artifactId>javax.servlet-api</artifactId>\r\n        <version>3.1.0</version> <scope>provided</scope>\r\n    </dependency>\r\n    <!-- jsp依赖 -->\r\n    <dependency>\r\n        <groupId>javax.servlet.jsp</groupId>\r\n        <artifactId>jsp-api</artifactId>\r\n        <version>2.2.1-b03</version>\r\n        <scope>provided</scope>\r\n    </dependency>\r\n    <!--加入springMVC依赖-->\r\n    <dependency>\r\n        <groupId>org.springframework</groupId>\r\n        <artifactId>spring-webmvc</artifactId>\r\n        <version>5.2.5.RELEASE</version>\r\n    </dependency>\r\n</dependencies>\r\n加入插件\r\n\r\n<resources>\r\n    <resource>\r\n        <directory>src/main/java</directory><!--所在的目录-->\r\n        <includes><!--包括目录下的.properties,.xml 文件都会扫描到-->\r\n            <include>**/*.properties</include>\r\n            <include>**/*.xml</include>\r\n        </includes>\r\n        <filtering>false</filtering>\r\n    </resource>\r\n</resources>\r\n<plugins>\r\n    <plugin>\r\n        <artifactId>maven-compiler-plugin</artifactId>\r\n        <version>3.1</version>\r\n        <configuration>\r\n            <source>1.8</source>\r\n            <target>1.8</target>\r\n        </configuration>\r\n    </plugin>\r\n</plugins>\r\n第三步注册中央调度器\r\n\r\n中央调度器为一个Servlet，名称为DispatcherServlet中央调度器的全限定性类名在导入的 Jar 文件 spring-webmvc-5.2.5.RELEASE.jar 的第一个包 org.springframework.web.servlet下可找到\r\n\r\n<load-on-startup/>标签:\r\n\r\n在<servlet/>中添加<load-on-startup/>的作用是，标记是否在Web服务器（这里是Tomcat）启动时会创建这个 Servlet 实例，即是否在 Web 服务器启动时调用执行该 Servlet 的 init()方法，而不是在真正访问时才创建。它的值必须是一个整数。\r\n\r\n当值大于等于 0 时，表示容器在启动时就加载并初始化这个 servlet，数值越小，该 Servlet的优先级就越高，其被创建的也就越早；\r\n\r\n当值小于 0 或者没有指定时，则表示该 Servlet 在真正被使用时才会去创建。\r\n\r\n当值相同时，容器会自己选择创建顺序。\r\n\r\n<url-pattern/>标签:\r\n\r\n可以写为 / ，建议写为*.do 的形式\r\n\r\n配置文件的位置和名称\r\n\r\n注册完毕后，可直接在服务器上发布运行。此时，访问浏览器页面，控制台均会抛出FileNotFoundException 异常。即默认要从项目根下的 WEB-INF 目录下找名称为 Servlet 名称-servlet.xml 的配置文件。这里的“Servlet 名称”指的是注册中央调度器<servlet-name/>标签中指定的 Servlet 的 name 值。本例配置文件名为 springmvc-servlet.xml。\r\n\r\n而一般情况下，配置文件是放在类路径下的，即resources目录下，所以在注册中央调度器，需要为sprigMVC配置文件路径\r\n\r\n<!--配置springMVC核心容器对象DispatcherServlet-->\r\n<servlet>\r\n    <servlet-name>springmvc</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:applicationcontext-servlet.xml</param-value>\r\n    </init-param>\r\n    <!--在Tomcat启动后，创建servlet对象\r\n    load-on-startup:表示Tomcat启动后创建对象的顺序，它的值是整数，数值越小，Tomcat创建对象的事件越早，大于等于0\r\n    -->\r\n    <load-on-startup>1</load-on-startup>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>springmvc</servlet-name>\r\n    <!--可以写为 / ，建议写为*.do 的形式-->\r\n    <url-pattern>*.do</url-pattern>\r\n</servlet-mapping>\r\n第四步：创建springMVC配置文件\r\n\r\n声明组件扫描器\r\n\r\n配置视图解析器\r\n\r\nSpringMVC 框架为了避免对于请求资源路径与扩展名上的冗余，在视图解析器InternalResouceViewResolver 中引入了请求的前辍与后辍。而 ModelAndView 中只需给出要跳转页面的文件名即可，对于具体的文件路径与文件扩展名，视图解析器会自动完成拼接。\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n    <!--开启注解扫描-->\r\n    <context:component-scan base-package=\"school.xauat\"></context:component-scan>\r\n\r\n    <!--配置视图解析器-->\r\n    <bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <property name=\"prefix\" value=\"/WEB-INF/view/\"></property>\r\n        <property name=\"suffix\" value=\".jsp\"></property>\r\n    </bean>\r\n</beans>\r\n第五步：创建Controller类\r\n\r\n使用@Controller注解\r\n\r\n使用@RequestMapping注解\r\n\r\n@RequestMapping:（可以加载在类上面，也可以加载在方法上，若类和方法上都加的有，先访问类，再访问方法）\r\n\r\n     设置请求映射，把请求和控制层中的方法设置映射关系\r\n\r\n     当请求路径和@RequestMapping的value属性值一样时，则该注解所标注的方法即为处理请求的方法\r\n\r\n method:用来设置请求方式，只有客户端发送请求的方式和method的值一致，才能处理请求\r\n\r\n\r\n\r\n     请求方式:GET 查询    POST 添加    PUT 修改     DELETE 删除\r\n\r\n params:用来设置客户端传到服务器的数据，支持表达式\r\n\r\n     -username：必须包含username参数\r\n\r\n     -!username：不能包含username参数\r\n\r\n     -username = admin ：username必须等于admin\r\n\r\n     -username != admin ：username必须不等于admin\r\n\r\n headers:用来设置请求头信息，所发送的请求的请求头信息一定要和headers属性中所设置的一致\r\n\r\n@Controller()\r\npublic class TestServlet {\r\n    @RequestMapping(value = \"/some.do\")\r\n    public ModelAndView doSome(){\r\n        //表示本次请求的处理结果\r\n        //Model:数据，请求处理完成后，要显示给用户\r\n        //View:视图，比如jsp等\r\n        ModelAndView mv = new ModelAndView();\r\n        //添加数据，底层执行request.setRequestContext();\r\n        mv.addObject(\"msg\",\"欢迎使用SpringMVC做web项目\");\r\n        mv.addObject(\"fun\",\"执行doSome方法\");\r\n        //指定视图，指定视图的完整路径\r\n        //框架对视图执行forward操作\r\n        mv.setViewName(\"show\");\r\n        return mv;\r\n    }\r\n}\r\n第六步：创建主页面和定义目标页面\r\n\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<a href=\"some.do\">发起some.do的请求</a>\r\n</body>\r\n</html>\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\nSpringMVC的第一个项目\r\n<h3>msg数据:${msg}</h3><br/>\r\n<h3>fun数据:${fun}</h3>\r\n</body>\r\n</html>\r\n使用SpringMVC框架web请求处理顺序\r\n', '2021-04-07 22:07:33', 'https://picsum.photos/id/240/300/200', '原创', b'0', b'0', b'0', 'SpringMVC核心技术', '2021-04-08 16:48:47', 9, 45, 1, 'springMVC又 叫Spring web mvc。是Spring框架中的一部分，是Spring3.0后发布的。\r\n1、基于MVC架构模式：MVC架构模式\r\n\r\n2、容易理解上手快，使用简单：可以开发一个注解的SpringMVC项目，SpringMVC也是轻量级的框架，jar包很小，不依赖特定的接口和类。\r\n\r\n3、作为Spring的一部分，能够使用Spring框架的IOC容器和Aop编程。方便整合Str');
INSERT INTO `t_blog` VALUES (60, b'1', b'1', '二分查找查找指定值\r\n这个挺简单的，直接上代码吧\r\n\r\n```java\r\n//获取值是k的位置，找不到则返回-1\r\n    public static int getK(int[] a, int k){\r\n        if(a.length == 0){\r\n            return -1;\r\n        }\r\n        int l = 0;\r\n        int r = a.length - 1;\r\n        //注意这里的判断条件，是必须允许 l = r 的情况存在的\r\n        //因为可能会出现刚好到最后左边指针到右边指针只有1个元素，而且这个元素恰恰就是我们想找的k\r\n        while (l <= r){\r\n            int mid = (l + r) / 2;\r\n            //如果mid元素已经是k了，那么直接返回\r\n            if (a[mid] == k){\r\n                return mid;\r\n            //查找左边的\r\n            }else if(a[mid] > k) {\r\n                r = mid - 1;\r\n            //查找右边的\r\n            }else {\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        //如果没有找到指定的值，那么直接返回-1\r\n        return -1;\r\n    }\r\n\r\n```\r\n\r\n用二分查找找到小于或者等于k的最大值\r\n思路：如果mid元素是小于或等于k，往右找，如果大于k，往左边找，直到找到一个值，最接近与k的。\r\n看代码中标注了 处地方，下面解释为什么如此设计\r\n\r\n    //获取值<=k的最大值\r\n    public static int uperK(int[] a, int k){\r\n        int l = 0;\r\n        int r = a.length - 1;\r\n        //标注1： 这里是l<r，\r\n        while(l < r){\r\n            //标注2： 这样的操作是为了取高位\r\n            int mid = (l + r + 1) / 2;\r\n            if(a[mid] <= k) { //标注3：因为a[mid]<=k,所以a[mid]可能=k，所以mid坐标也满足条件，l = mid而不是mid+1;\r\n                l = mid;\r\n            }else{\r\n                r= mid - 1; //这是a[mid] > k的时候。\r\n            }\r\n        }\r\n        //标注4： 因为此时求得到的是最接近于目标值k的数，\r\n        // 如果最小值都大于k的话，那么就没有办法得到了，所以就进行一个判断\r\n        if(a[l] > k) return -1;\r\n        //标注5： 其实这里无论返回 a[l] 还是a[r]都行，循环的退出时间是l == r 的时候\r\n        return a[l];\r\n    }\r\n\r\n标注1解释：\r\n因为我们的目的是“通过缩小范围，得到当l = r的时候，l 标记的值”的情况，所以直到 l< r条件被打破的时候的l就是我们要求的值。这跟上一道问题“查找指定值”是不一样的\r\n\r\n标注2解释：\r\n标注2： 这样的操作是为了让 mid 标志 取高位， 才能让循环顺序跳出来，举个死循环的例子\r\n注意这个例子采取的是mid = (l + r) / 2 取低位的情况，为了展示死循环的形成过程，我们原题的做法是取高位的\r\n\r\n数据： int[] num = {1,2,3,4,5,6,7,8,9}， 查找小于或者等于8的最小值。\r\n\r\n\r\n如上图，此时左坐标是0, 右是8, 那么\r\nmid = (0 + 8) / 2 = 4，num[mid] = num[4] <= k, ,向右找结果,所以有 l = mid，开始下一个循环。\r\n\r\n\r\n此时的mid = 6, num[6] = 7;\r\nnum[mid] <= k, 向右找 l = 6\r\n下一步:\r\n\r\n可以得到 l = 6, r = 8, mid = (6+8) / 2 = 7，a[7] = 8 <= k，那么有l = mid = 7， r = 8,\r\n推到得到mid = 7， 问题来了上一步的时候mid已经是7了，结果会使得mid一直是7，一直循环下去。\r\n所以如果我们求的是二分法求小于或者等于k的最大值的话，我们mid 必须取得中值的上界,\r\n\r\n标注3解释：\r\n因为a[mid]<=k,所以a[mid]可能=k，所以mid坐标也满足条件，l = mid而不是mid+1;\r\n标注4解释：\r\n如果最小值都大于k的话，那么就没有办法得到了，所以就进行一个判断\r\n最典型的例子是：\r\n{1,2,3,4,5,6,7,8} ,然后k是0的时候， 这样得到的结果只能是数组中最接近与k的数，但是如果他还是大于k\r\n你们可以算一下上面这个例子，到最后num[l] 是1, 永远都大于0, 那么得返回取不到值，所以return -1;\r\n标注5解释：\r\n其实这里无论返回 a[l] 还是a[r]都行，循环的退出时间是l == r 的时候\r\n二分查找大于或等于k的最小值\r\n直接上代码了，想必大家都清楚了，看了上面问题2的解释\r\n\r\n```java\r\npublic static int downK(List list, int key){\r\n    while (low < high) {\r\n                //这里进行的是取低位， 也是为了使得循环可以正确退出，防止死循环\r\n		int mid = (low + high)/2;\r\n		if (a[mid] < key) {\r\n		    low = mid +1;\r\n		} else { //a[mid] >= key\r\n		    high = mid;   //因为mid也满足情况\r\n		}\r\n	}\r\n            //这里进行检查的原因参考上面的标注\r\n	if (a[high] >= key) {\r\n		return high;\r\n	} else {\r\n	    return -1;\r\n	}\r\n}\r\n```\r\n分类: 两天一道leetcode', '2019-01-01 00:00:50', 'https://picsum.photos/id/247/300/200', '原创', b'0', b'1', b'1', '二分查找', '2020-04-08 16:49:16', 5, 9, 1, '二分查找三种形式');
INSERT INTO `t_blog` VALUES (77, b'1', b'1', '因为AVL自平衡树是建立在二叉排序树的基础上的，所以这里我先简单描述一下二叉排序树和代码实现。\r\n\r\n二叉排序树(Binary Sort(Search) Tree)(BST)\r\n二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。 特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点\r\n\r\n比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：\r\n\r\n\r\n\r\n因为二叉排序树的插入比较简单，下面就直接代码实现了\r\n\r\n首先创建一个节点类(因为后面的自平衡也会使用这个节点，只是在节点中添加新的方法，后面就不再过多赘述了)\r\n\r\nclass Node{\r\n    public int val;\r\n    public Node left;\r\n    public Node right;\r\n\r\n    public Node(int val){\r\n        this.val = val;\r\n    }\r\n\r\n    public void add(Node node){\r\n        if(node == null)\r\n            return;\r\n        if(node.val < this.val){\r\n            if(this.left == null) {\r\n                this.left = node;\r\n            }else {\r\n                this.left.add(node);\r\n            }\r\n        }else {\r\n            if(this.right == null){\r\n                this.right = node;\r\n            }else {\r\n                this.right.add(node);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void infixOrder(){\r\n        if(this.left != null){\r\n            this.left.infixOrder();\r\n        }\r\n        System.out.println(this);\r\n        if(this.right != null){\r\n            this.right.infixOrder();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Node{\" +\r\n                \"val=\" + val +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n创建二叉搜索树\r\n\r\nclass BinarySortTree{\r\n    private Node root;\r\n\r\n    public void setRoot(Node root) {\r\n        this.root = root;\r\n    }\r\n\r\n    public void add(Node node){\r\n        if(root == null){\r\n            root = node;\r\n            return;\r\n        }\r\n        root.add(node);\r\n    }\r\n\r\n    public void infixOrder(){\r\n        if(root != null){\r\n            root.infixOrder();\r\n            return;\r\n        }\r\n        System.out.println(\"二叉排序树为空~~~\");\r\n    }\r\n    \r\n}\r\n二叉搜索树和节点类已经创建好了，如果需要添加节点，主需要遍历数组添加节点\r\n\r\n\r\n\r\n    BinarySortTree binarySortTree = new BinarySortTree();\r\n    int[] arr = {7, 3, 10, 12, 5, 1, 9};\r\n    for (int i = 0; i < arr.length; i++) {\r\n    binarySortTree.add(new Node(arr[i]));\r\n下面实现二叉排序树的删除节点功能\r\n\r\n因为删除一个节点需要拿到这个节点和这个和节点的双亲节点所以在节点类中添加search()和searchParent()方法，并封装在树类中\r\n\r\npublic Node search(int val){\r\n    if(this.val == val){\r\n        return this;\r\n    }\r\n    if(val < this.val){\r\n        if (this.left != null){\r\n            return this.left.search(val);\r\n        }else\r\n            return null;\r\n    }else {\r\n        if (this.right != null){\r\n            return this.right.search(val);\r\n        }else\r\n            return null;\r\n    }\r\n}\r\npublic Node search(int val){\r\n    if(root != null){\r\n        return root.search(val);\r\n    }\r\n    return null;\r\n}\r\npublic Node searchParent(int val){\r\n    if(this.left != null && this.left.val == val ||\r\n            this.right != null && this.right.val == val){\r\n        return this;\r\n    }\r\n    if(val < this.val && this.left != null){\r\n        return this.left.searchParent(val);\r\n    }else if(val > this.val && this.right != null){\r\n        return this.right.searchParent(val);\r\n    }\r\n    return null;\r\n}\r\npublic Node searchParent(int val){\r\n    if(root != null){\r\n        return root.searchParent(val);\r\n    }\r\n    return null;\r\n}\r\n二叉排序树的删除情况比较复杂，有下面三种情况需要考虑\r\n\r\n\r\n\r\n1、删除叶子节点 (比如：2, 5, 9, 12)\r\n\r\n\r\n\r\n\r\n\r\nif(target.left == null && target.right == null){//叶子节点\r\n    if (parent.left != null && parent.left.val == val){\r\n        parent.left = null;\r\n        return;\r\n    }\r\n    if(parent.right != null && parent.right.val == val){\r\n        parent.right = null;\r\n        return;\r\n    }\r\n\r\n2、删除只有一颗子树的节点 (比如：1)\r\n\r\n\r\n\r\nelse {//有一个子树的叶子节点\r\n   if(parent.left.val == val){\r\n       if(target.left != null){\r\n           parent.left = target.left;\r\n           return;\r\n       }\r\n       if(target.right != null){\r\n           parent.left = target.right;\r\n           return;\r\n       }\r\n   }else {\r\n       if(target.left != null){\r\n           parent.right = target.left;\r\n           return;\r\n       }\r\n       if(target.right != null){\r\n           parent.right= target.right;\r\n           return;\r\n       }\r\n   }\r\n3、删除有两颗子树的节点. (比如：7, 3，10 )\r\n\r\n\r\n\r\n\r\n\r\n这里有两种方式，要么是删除右子树的最小值，要么是删除左子树的最大值，两种方法我都是实现，实际中只需要调用一种\r\n\r\npublic int delLeftMax(Node node){\r\n    Node target = node;\r\n    while (target.right != null){\r\n        target = target.right;\r\n    }\r\n    delNode(target.val);\r\n    return target.val;\r\n}\r\n\r\npublic int delRightTreeMin(Node node){\r\n    Node target = node;\r\n    while(target.left != null){\r\n        target = target.left;\r\n    }\r\n    delNode(target.val);\r\n    return target.val;\r\n}\r\nelse if(target.left != null && target.right != null){//两颗子树的非叶子节点\r\n   int minVal = delRightTreeMin(target.right);\r\n   target.val = minVal;\r\n删除节点代码总结\r\n\r\npublic void delNode(int val){\r\n    if (root == null){\r\n        return;\r\n    }\r\n    if (root.val == val && root.left == null && root.right == null){\r\n        root = null;\r\n        return;\r\n    }\r\n    Node target = search(val);\r\n    if (target == null)\r\n        return;\r\n    Node parent = searchParent(val);\r\n    if (target.left == null && target.right == null){\r\n        if (parent.left != null && parent.left.val == val){\r\n            parent.left = null;\r\n            return;\r\n        }else{\r\n            parent.right = null;\r\n            return;\r\n        }\r\n    }else if (target.left != null && target.right != null){\r\n        int maxVal = delLeftMax(target.left);\r\n        target.val = maxVal;\r\n    }else {\r\n        if (parent.left != null && parent.left.val == val){\r\n            if (target.left != null){\r\n                parent.left = target.left;\r\n                return;\r\n            }else {\r\n                parent.left = target.right;\r\n                return;\r\n            }\r\n        }else {\r\n            if (target.left != null){\r\n                parent.right = target.left;\r\n                return;\r\n            }else {\r\n                parent.right = target.right;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n以上就是二叉排序树的实现过程。分析二叉排序可能的问题\r\n\r\n给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.\r\n\r\n\r\n\r\n左边BST 存在的问题分析:\r\n\r\n1、左子树全部为空，从形式上看，更像一个单链表.\r\n\r\n2、插入速度没有影响\r\n\r\n3、查询速度明显降低(因为需要依次比较), 不能发挥BST 的优势，因为每次还需要比较左子树，其查询速度比 单链表还慢\r\n\r\n4、解决方案-平衡二叉树(AVL) \r\n\r\n平衡二叉树\r\n平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。\r\n\r\n具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。\r\n\r\n因为这里需要讨论树的深度，所以在节点类中添加了三个方法，height()、leftHeight()、rightHeight()\r\n\r\npublic int leftHeight(){\r\n    if (left != null){\r\n        return left.height();\r\n    }\r\n    return 0;\r\n}\r\npublic int rightHeight(){\r\n    if (right != null){\r\n        return right.height();\r\n    }\r\n    return 0;\r\n}\r\npublic int height(){\r\n    return Math.max(left == null ? 0 : left.height(),\r\n            right == null ? 0 : right.height()) + 1;\r\n}\r\nAVL树左旋转\r\n\r\n\r\n\r\n问题：当插入8 时 rightHeight() - leftHeight() > 1 成立，此时，不再是一颗avl树了.\r\n\r\n怎么处理--进行左旋转.\r\n\r\n1、 创建一个新的节点 newNode (以4这个值创建) ,创建一个新的节点，值等于当前根节点的值\r\n\r\n//把新节点的左子树设置了当前节点的左子树\r\n\r\n2、 newNode.left = left //把新节点的右子树设置为当前节点的右子树的左子树\r\n\r\n3、newNode.right =right.left; ////把当前节点的值换为右子节点的值\r\n\r\n4、value=right.value;\r\n\r\n//把当前节点的右子树设置成右子树的右子树\r\n\r\n5.、right=right.right;\r\n\r\n////把当前节点的左子树设置为新节点\r\n\r\n6、 left=newLeft;\r\n\r\n\r\n\r\n左旋转代码实现\r\n\r\npublic void leftRotate(){\r\n    Node newNode = new Node(val);\r\n    newNode.left = left;\r\n    newNode.right = right.left;\r\n    val = right.val;\r\n    right = right.right;\r\n    left = newNode;\r\n}\r\n\r\nAVL右旋转\r\n\r\n\r\n\r\n问题：当插入6 时 leftHeight()  - rightHeight()  > 1 成立，此时，不再是一颗avl树了.\r\n\r\n怎么处理--进行右旋转.[就是降低左子树的高度], 这里是将 9 这个节点，通过右旋转，到右子树\r\n\r\n1.、创建一个新的节点 newNode (以10这个值创建) ,创建一个新的节点，值等于当前根节点的值\r\n\r\n//把新节点的右子树设置了当前节点的右子树\r\n\r\n2、 newNode.right = right\r\n\r\n//把新节点的左子树设置为当前节点的左子树的右子树\r\n\r\n3、newNode.left =left.right;\r\n\r\n////把当前节点的值换为左子节点的值\r\n\r\n4、value=left.value;\r\n\r\n//把当前节点的左子树设置成左子树的左子树\r\n\r\n5、 left=left.left;\r\n\r\n////把当前节点的右子树设置为新节点\r\n\r\n6、 right=newLeft;\r\n\r\n\r\n\r\n右旋转代码实现\r\n\r\npublic void rightRotate(){\r\n    Node newNode = new Node(val);\r\n    newNode.right = right;\r\n    newNode.left = left.right;\r\n    val = left.val;\r\n    left = left.left;\r\n    right = newNode;\r\n}\r\n\r\n双旋转分析\r\n\r\n前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列 int[] arr = { 10, 11, 7, 6, 8, 9 };  运行原来的代码可以看到，并没有转成 AVL树. int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL树\r\n\r\n\r\n\r\n所以这里应该先对根节点的左节点进行左旋，再进行右旋，重写add方法\r\n\r\n\r\n\r\npublic void add(Node node){\r\n    if (node.val < val){\r\n        if (left != null){\r\n            left.add(node);\r\n        }else {\r\n            left = node;\r\n        }\r\n    }else {\r\n        if (right != null){\r\n            right.add(node);\r\n        }else {\r\n            right = node;\r\n        }\r\n    }\r\n    if((leftHeight() - rightHeight()) > 1){\r\n        if (left != null && (left.rightHeight() - left.leftHeight()) > 1){\r\n            left.leftRotate();\r\n            rightRotate();\r\n        }else {\r\n            rightRotate();\r\n            return;\r\n        }\r\n    }\r\n    if ((rightHeight() - leftHeight()) > 1){\r\n        if (right != null && (right.leftHeight() - right.rightHeight()) > 1){\r\n            right.rightRotate();\r\n            leftHeight();\r\n        }else {\r\n            leftRotate();\r\n            return;\r\n        }\r\n    }\r\n\r\n', '2020-11-01 17:33:31', 'https://picsum.photos/id/377/300/200', '原创', b'0', b'1', b'1', 'AVL自平衡树', '2021-04-10 17:33:31', 15, 9, 1, '在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，他们在1962年的论文《An algorithm for the organization of information》');

-- ----------------------------
-- Table structure for t_blog_tags
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags`  (
  `blogs_id` bigint(20) NOT NULL,
  `tags_id` bigint(20) NOT NULL,
  INDEX `FK5feau0gb4lq47fdb03uboswm8`(`tags_id`) USING BTREE,
  INDEX `FKh4pacwjwofrugxa9hpwaxg6mr`(`blogs_id`) USING BTREE,
  CONSTRAINT `FK5feau0gb4lq47fdb03uboswm8` FOREIGN KEY (`tags_id`) REFERENCES `t_tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKh4pacwjwofrugxa9hpwaxg6mr` FOREIGN KEY (`blogs_id`) REFERENCES `t_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_blog_tags
-- ----------------------------
INSERT INTO `t_blog_tags` VALUES (49, 46);
INSERT INTO `t_blog_tags` VALUES (58, 46);
INSERT INTO `t_blog_tags` VALUES (58, 56);
INSERT INTO `t_blog_tags` VALUES (60, 59);
INSERT INTO `t_blog_tags` VALUES (60, 56);
INSERT INTO `t_blog_tags` VALUES (44, 32);
INSERT INTO `t_blog_tags` VALUES (41, 26);
INSERT INTO `t_blog_tags` VALUES (77, 76);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) NOT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `blog_id` bigint(20) NULL DEFAULT NULL,
  `parent_comment_id` bigint(20) NULL DEFAULT NULL,
  `admin_comment` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKke3uogd04j4jx316m1p51e05u`(`blog_id`) USING BTREE,
  INDEX `FK4jj284r3pb7japogvo6h72q95`(`parent_comment_id`) USING BTREE,
  CONSTRAINT `FK4jj284r3pb7japogvo6h72q95` FOREIGN KEY (`parent_comment_id`) REFERENCES `t_comment` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (61, '/images/avatar.jpg', '测试评论', '2021-04-08 21:23:41', 'zhangsan@qq.com', '张三', 41, NULL, b'0');
INSERT INTO `t_comment` VALUES (67, '/images/avatar.jpg', '测试的好', '2021-04-08 21:34:59', 'lisi@qq.com', '李四', 41, 61, b'0');
INSERT INTO `t_comment` VALUES (68, '/images/avatar.jpg', '哈哈哈', '2021-04-09 08:59:23', 'wangwu@qq.com', '王五', 41, 67, b'0');
INSERT INTO `t_comment` VALUES (70, '/images/avatar.jpg', '测试评论+1', '2021-04-09 09:17:09', 'zhaoliu@qq.com', '赵六', 41, NULL, b'0');
INSERT INTO `t_comment` VALUES (73, '/images/adminAvatar.jpg', '欢迎大家评论', '2021-04-09 09:56:23', '834187150@qq.com', 'dunk_code', 41, NULL, b'1');
INSERT INTO `t_comment` VALUES (74, '/images/adminAvatar.jpg', '测试的好', '2021-04-09 09:56:36', '834187150@qq.com', 'dunk_code', 41, 70, b'1');
INSERT INTO `t_comment` VALUES (75, '/images/avatar.jpg', '博主好帅', '2021-04-09 09:57:24', 'zhouzhou@qq.com', '粥粥', 41, 73, b'0');
INSERT INTO `t_comment` VALUES (78, '/images/adminAvatar.jpg', '测试评论', '2021-04-09 17:34:00', '834187150@qq.com', 'dunk_code', 77, NULL, b'1');
INSERT INTO `t_comment` VALUES (81, '/images/avatar.jpg', '写的不错', '2021-04-09 17:36:49', '778899@qq.com', '粥粥', 77, NULL, b'0');
INSERT INTO `t_comment` VALUES (82, '/images/avatar.jpg', '写的不错', '2021-04-09 17:37:01', '778899@qq.com', '粥粥', 77, 78, b'0');

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (26, 'java');
INSERT INTO `t_tag` VALUES (27, 'python');
INSERT INTO `t_tag` VALUES (29, 'go');
INSERT INTO `t_tag` VALUES (30, 'servlet');
INSERT INTO `t_tag` VALUES (32, 'springBoot');
INSERT INTO `t_tag` VALUES (46, 'SpringMVC');
INSERT INTO `t_tag` VALUES (56, 'Spring');
INSERT INTO `t_tag` VALUES (59, '二分查找');
INSERT INTO `t_tag` VALUES (76, '二叉树');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (1, 'JavaSE');
INSERT INTO `t_type` VALUES (2, '前端框架');
INSERT INTO `t_type` VALUES (3, '错误日志');
INSERT INTO `t_type` VALUES (4, 'JavaScript');
INSERT INTO `t_type` VALUES (8, '前端框架');
INSERT INTO `t_type` VALUES (9, '数据结构与算法');
INSERT INTO `t_type` VALUES (10, '数据库');
INSERT INTO `t_type` VALUES (11, 'Linux');
INSERT INTO `t_type` VALUES (12, '设计模式');
INSERT INTO `t_type` VALUES (13, 'CSS');
INSERT INTO `t_type` VALUES (14, 'HTML');
INSERT INTO `t_type` VALUES (18, 'UDP');
INSERT INTO `t_type` VALUES (25, 'TCP');
INSERT INTO `t_type` VALUES (33, '开发常用');
INSERT INTO `t_type` VALUES (42, 'SpringBoot');
INSERT INTO `t_type` VALUES (45, 'Spring生态圈');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) NOT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` int(11) NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, '/images/adminAvatar.jpg', '2021-04-06 16:57:51', '834187150@qq.com', 'dunk_code', '96e79218965eb72c92a549dd5a330112', 1, '2021-04-06 16:58:22', 'dunkcode');

SET FOREIGN_KEY_CHECKS = 1;
